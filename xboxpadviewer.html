<!--
XBox Pad Viewer
for use with OBS streaming.

Keep the css and png file in the same place with this file.
Add BrowserSource and set it to load this html file.
Width and height for one gamepad to display is 220x156.
Press any key on the gamepad and the viewer will show the buttons.

ⓒ 2017 Dinir Nertan, @DinirNertan, DinirNertan@gmail.com
   Use it freely, just don't delete my name on the code.
-->
<!DOCTYPE html>
<html lang="en">

	<head>
		<meta content="text/html;charset=utf-8" http-equiv="content-type">
		<meta content="utf-8" http-equiv="encoding">
		<meta name="viewport"
					content="width=device-width, initial-scale=1.0" />
		<title>XBox Pad Viewer</title>
		<link rel="stylesheet" href="mapping.css">
	</head>
	
	<script>
		window.onload = function() {
			document.body.style.fontSize = "16px";
			if(gpConstants.useFadeOut) { timeValues.fpsCheck(); }
		};	

		var gpConstants = {
			// how big the thumb sticks should be? (0~100)
			thumbSize: 60
			// what color the backcground of the pressed button should turn to?
			// this changes hue of the default color by degrees. (0~360)
			// the color is red at 0 degree.
			,pressedButtonBackgroundColorHue: "0"
			// what color the text of the pressed button should turn to?
			// if you want to change the background color for pressed buttons, change the `dot.png` in the same folder.
			,pressedButtonColor: "orange"
			// how responsive should thumb stick tracking be? (0~)
			// it refers to this value when deciding if you moved the stick.
			// eg) 3 -> will track the position of the stick DOM
			// to 10^-3 below the decimal point.
			,axisSensitivity: 1
			// should unpressed buttons fade out? (true/false)
			,useFadeOut: true
			// set the seconds the fade-out starts in the array.
			,fadeOutTime: [4, 12]
			// set the strength of the fade-out for each timing above. (0~1)
			,fadeOutStrength: [.5, .9]
			// set the seconds the fade-out applies through.
			,fadeOutDuration: 4
		};

		// these are things needed to count a tick of rAF per second.
		// in `gamepadDOMs.update` which is called in every tick,
		// `timeValues.fpsIncrease` is called for 1 second.
		// `timeValues.fpsCheck` is called on window load which stops
		// counting after 1 second from loading.
		var timeValues = {
			fps: 0
			,fpsChecked: false
			,fpsIncrease: function() { timeValues.fps++; }
			,fpsCheck: function() {
				var o = setTimeout(function() {
					timeValues.fpsChecked = true;
					clearTimeout(o);
				}, 1000);
			}
		};

		// for the 'in' keyword: I used the code below as a reference.
		// https://github.com/luser/gamepadtest/blob/master/gamepadtest.js
		var haveEvents = 'GamepadEvent' in window;
		var haveWebkitEvents = 'WebKitGamepadEvent' in window;
		var rAF = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.requestAnimationFrame;

		// this will contain gamepad objects.
		var gamepads = {};
		if(gpConstants.useFadeOut) {
			var gamepadTimestamps = {};
			function gamepadTimestamp() {
				var buttons = [];
				var axes = {};

				this.buttonAdd = function() { buttons.push({t:0,v:0}); };
				this.axisAdd = function(n) { axes[n] = {t:0,v:0}; };

				this.getButtonStatus = function(n) {
					return buttons[n];
				};
				this.getAxisTimestamp = function(n) {
					return axes[n].t;
				};

				this.age = function() {
					var max = timeValues.fps * gpConstants.fadeOutTime[gpConstants.fadeOutTime.length-1];
					for(var i=0; i<buttons.length; i++) {
						if(buttons[i].t<max) {
							buttons[i].t++;
						}
					}
					for(a in axes) {
						if(axes[a].t<max) {
							axes[a].t++;
						}
					}
				};

				this.buttonUpdate = function(n,v) {
					if(buttons[n].v !== v) {
						buttons[n].t = 0;
						buttons[n].v = v;
						return true;
					} else {
						return false;
					}
				};
				this.axisUpdate = function(n,v) {
					if(axes[n].v !== v) {
						axes[n].t = 0;
						axes[n].v = v;
						return true;
					} else {
						return false;
					}
				};
			};
		}

		var gamepadHandler = {
			connect: function(e) {
				gamepads[e.index] = e;
				console.log("connected: %d", e.index);
				gamepadDOMs.add(e);
			},
			disconnect: function(index) {
				console.log("disconnecting: %d", index);
				gamepadDOMs.remove(index);
				delete gamepads[index];
			},
			scan: function() {
				var gamepadsFromNavigator = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
				for(var i=0; i<gamepadsFromNavigator.length; i++) {
					if(gamepadsFromNavigator[i]) {
						if(gamepadsFromNavigator[i].index in gamepads) {
							gamepads[gamepadsFromNavigator[i].index] = gamepadsFromNavigator[i];
						} else {
							gamepadHandler.connect(gamepadsFromNavigator[i]);
						}
					} else if((gamepadsFromNavigator[i] === null || gamepadsFromNavigator[i] === undefined)
					  && document.getElementById(`gp${i}`)) {
						gamepadHandler.disconnect(i);
					}
				}
			}
		};

		var gamepadMapping = {
			"Microsoft Controller (Vendor: 045e Product: 02d1)": {
				buttons: [
					{name:"A", type:"button"}
					,{name:"B", type:"button"}
					,{name:"X", type:"button"}
					,{name:"Y", type:"button"}
					,{name:"LB", type:"button"}
					,{name:"RB", type:"button"}
					,{name:"Se", type:"button"}
					,{name:"St", type:"button"}
					,{name:"ⓧ", type:"button"}
					,{name:"L", type:"button thumb"}
					,{name:"R", type:"button thumb"}
				]
				,axes: [
					{name:"L", type:"thumb"}
					,{name:"L", type:"thumb"}
					,{name:"LT", type:"button shoulder"}
					,{name:"R", type:"thumb"}
					,{name:"R", type:"thumb"}
					,{name:"RT", type:"button shoulder"}
					,{name:"D", type:"button polar"}
					,{name:"D", type:"button polar"}
				]
			}
			,"Xbox 360 Controller (XInput STANDARD GAMEPAD)": {
				buttons: [
					{name:"A", type:"button"}
					,{name:"B", type:"button"}
					,{name:"X", type:"button"}
					,{name:"Y", type:"button"}
					,{name:"LB", type:"button"}
					,{name:"RB", type:"button"}
					,{name:"LT", type:"button"}
					,{name:"RT", type:"button"}
					,{name:"Se", type:"button"}
					,{name:"St", type:"button"}
					,{name:"L", type:"button thumb"}
					,{name:"R", type:"button thumb"}
					,{name:"U", type:"button"}
					,{name:"D", type:"button"}
					,{name:"L", type:"button"}
					,{name:"R", type:"button"}
				]
				,axes: [
					{name:"L", type:"thumb"}
					,{name:"L", type:"thumb"}
					,{name:"R", type:"thumb"}
					,{name:"R", type:"thumb"}
				]
			}
		};

		var gamepadDOMs = {
			add: function(gp) {
				var isLinuxXpad = gp.id==="Microsoft Controller (Vendor: 045e Product: 02d1)";
				if(gpConstants.useFadeOut) {
					// create a couple of arrays for tracking button's timestamp
					gamepadTimestamps[gp.index] = new gamepadTimestamp();
					var gts = gamepadTimestamps[gp.index];
				}

				// create dom for a gamepad
				var d = document.createElement("div");
				d.setAttribute("id",`gp${gp.index}`);
				d.setAttribute("class",gp.id);

				// create dom for buttons
				var b = document.createElement("div");
				b.setAttribute("class","buttons");
				for(var i=0; i<gp.buttons.length; i++) {
					if(gamepadMapping[gp.id]) {
						var cur = gamepadMapping[gp.id].buttons[i];
						var e = document.createElement("span");
						if(cur.type === "button thumb") {} else {
							e.setAttribute("class",cur.type);
							e.innerHTML = `${cur.name}`;
						}
					} else {
						var e = document.createElement("span");
						e.setAttribute("class","button");
						e.innerHTML = i;
					}
					e.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`;
					e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
					b.appendChild(e);
					if(gpConstants.useFadeOut) { gts.buttonAdd(); }
				}
				d.appendChild(b);

				// create dom for axes
				var a = document.createElement("div");
				a.setAttribute("class","axes");
				var c; // c resides in e and represent the position of thumb stick.
				for(i=0; i<gp.axes.length; i++) {
					if(gamepadMapping[gp.id]) {
						var cur = gamepadMapping[gp.id].axes[i];
						if(cur.type === "thumb") {
							if(a.getElementsByClassName(`axis ${cur.name}`).length) {
								c.style.top = `${gpConstants.thumbSize/2}%`;
							} else {
								e = document.createElement("span");
								e.setAttribute("class",`axis ${cur.name}`);
								c = document.createElement("span");
								c.style.width = `${gpConstants.thumbSize}%`;
								c.style.height = `${gpConstants.thumbSize}%`;
								c.style.left = `${gpConstants.thumbSize/2}%`;
								c.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`;
								e.appendChild(c);
								e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
								a.appendChild(e);
								if(gpConstants.useFadeOut) { gts.axisAdd(cur.name); }
							}
						} else if(cur.type.match("button")) {
							e = document.createElement("span");
							e.setAttribute("class",cur.type);
							if(isLinuxXpad) {
								if(cur.type.match("shoulder")) {
									e.innerHTML = cur.name;
								} else if(cur.type.match("polar")) {
									// linux accepts dpad LR and dpad UD through
									// 6th and 7th axes respectively.
									e.innerHTML = i===6?"R":"D";
									var e2 = e.cloneNode(false);
									e2.innerHTML = i===6?"L":"U";
									e2.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`;
									e2.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
									b.appendChild(e2);
									if(gpConstants.useFadeOut) { gts.buttonAdd(); }
								}
							}
							e.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`;
							e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
							b.appendChild(e);
							if(gpConstants.useFadeOut) { gts.buttonAdd(); }
						}
					} else {
						e = document.createElement("span");
						e.setAttribute("class","axis");
						e.innerHTML = `${i} `;
						a.appendChild(e);
					}
				}
				d.appendChild(a);

				// attach gamepad dom to the document
				document.body.appendChild(d);
			},
			remove: function(index) {
				var d = document.getElementById(`gp${index}`);
				document.body.removeChild(d);
				delete gamepadTimestamps[index];
			},
			update: function() {
				gamepadHandler.scan();
				if(gpConstants.useFadeOut && !timeValues.fpsChecked) {
					timeValues.fpsIncrease();
				}
				for(j in gamepads) {
					var gp = gamepads[j];
					var isLinuxXpad = gp.id==="Microsoft Controller (Vendor: 045e Product: 02d1)";
					if(gpConstants.useFadeOut) {
						var gts = gamepadTimestamps[gp.index];
						gts.age();
					}
					var d = document.getElementById(`gp${gp.index}`);

					var b = d.getElementsByClassName("buttons")[0];
					for(var i=0; i<gp.buttons.length; i++) {
						var cur = gamepadMapping[gp.id].buttons[i];
						var e;
						var es = gp.buttons[i]; // each status of buttons
						var val = 100*es.value;
						if(cur.type === "button thumb") {
							e = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0];
							if(val===100) {
								e.style.background = "url(dot.png)";
							} else {
								e.style.background = "white";
							}
							// gamepadDOMs.opacityControl(
							// 	gts.buttonUpdate(i, val), 
							// 	gts.getButtonStatus(i), 
							// 	e
							// );
						} else {
							e = b.children[i]; // each dom for buttons
							e.style.backgroundSize = `100% ${val}%`;
							if(val) {
								e.style.color = gpConstants.pressedButtonColor;
							} else {
								e.style.color = "white";
							}
							if(gpConstants.useFadeOut) {
								gamepadDOMs.opacityControl(
									gts.buttonUpdate(i, val), 
									gts.getButtonStatus(i),
									e
								);
							}
						}
					}
					
					var a;
					for(i=0; i<gp.axes.length; i++) {
						if(gamepadMapping[gp.id]) {
							var cur = gamepadMapping[gp.id].axes[i];
							var val = gp.axes[i];
							if(cur.type === "thumb") {
								a = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0];
								var thumbMargin = (100-gpConstants.thumbSize)/2;

								// in Windows, axis0~4 is LeftThumbXY and RightThumbXY.
								// so I made it so if i is even it should be treated
								// as Y value.
								// in Linux, though, these XY values are 0, 1 and 3, 4.
								// I made my code bit dirty by
								// simply swapping i values just before
								// converting gamepad's value to the top and left value.
								var linuxXpadCalibration = isLinuxXpad && (i===3||i===4);
								if(linuxXpadCalibration) { i===3?i=4:i=3; } 
								if(i%2) {
									if(linuxXpadCalibration) { i===3?i=4:i=3; }
									a.style.top = `${thumbMargin+thumbMargin*val}%`;
								} else {
									if(linuxXpadCalibration) { i===3?i=4:i=3; }
									a.style.left = `${thumbMargin+thumbMargin*val}%`;
								}
								var valSerialized = 
								Math.pow(10,2*gpConstants.axisSensitivity+2)
								*parseFloat(a.style.left).toFixed(gpConstants.axisSensitivity)
								+Math.pow(10,gpConstants.axisSensitivity)
								*parseFloat(a.style.top).toFixed(gpConstants.axisSensitivity);
								if(gpConstants.useFadeOut) {
									gamepadDOMs.opacityControl(
										gts.axisUpdate(cur.name,valSerialized), 
										gts.getAxisTimestamp(cur.name),
										a.parentElement
									);
								}
							} else if(cur.type.match("button")) {
								if(isLinuxXpad) {
									var buttonNumber;
									if(cur.type.match("shoulder")) {
										buttonNumber = i===2?11:12;
										e = b.children[buttonNumber];
										val = 50+Math.floor(50*val);
										if(val) {
											e.style.color = gpConstants.pressedButtonColor;
										} else {
											e.style.color = "white";
										}
										e.style.backgroundSize = `100% ${val}%`;
										if(gpConstants.useFadeOut) {
											gamepadDOMs.opacityControl(
												gts.buttonUpdate(buttonNumber, val), 
												gts.getButtonStatus(buttonNumber),
												e
											);
										}
									} else if(cur.type.match("polar")) {
										var dpadX = i===6;
										var currentMinusPolarButton = dpadX?13:15;
										var currentPlusPolarButton = dpadX?14:16;
										buttonNumber
										= val>0?
												currentPlusPolarButton
												:val<0?
													currentMinusPolarButton
													:0;
										val = Math.abs(100*val);
										if(buttonNumber) {
											e = b.children[buttonNumber];
											e.style.backgroundSize = `100% ${val}%`;
											e.style.color = gpConstants.pressedButtonColor;
										} else {
											e = b.children[currentMinusPolarButton];
											e.style.backgroundSize
											= e.nextSibling.style.backgroundSize
											= "100% 0%";
											e.style.color
											= e.nextSibling.style.color
											= "white";
										}
										if(gpConstants.useFadeOut) {
											if(buttonNumber) {
												gamepadDOMs.opacityControl(
													gts.buttonUpdate(buttonNumber, val), 
													gts.getButtonStatus(buttonNumber),
													e
												);
											} else {
												gamepadDOMs.opacityControl(
													gts.buttonUpdate(currentMinusPolarButton, 0),
													gts.getButtonStatus(currentMinusPolarButton),
													b.children[currentMinusPolarButton]
												);
												gamepadDOMs.opacityControl(
													gts.buttonUpdate(currentPlusPolarButton, 0),
													gts.getButtonStatus(currentPlusPolarButton),
													b.children[currentPlusPolarButton]
												);
											}
										}
									}
								}
							}
						} else {
							var a = d.getElementsByClassName("axis");
							e = a[i];
							e.innerHTML = `${i}${gp.axes[i].toFixed(22)} `;
						}
					}

				}
				rAF(gamepadDOMs.update);
			}
			,opacityControl: function(isChanged, status, element) {
				if(element) {
					// button's status will be passed as {timestamp, value}.
					// axis' status will be passed as timestamp,
					// and then converted to {timestamp, value=0}.
					if(typeof status === "number") {
						status = {t:status, v:0};
					}
					if(isChanged || status.v) { 
						element.style.transition=`opacity 0s`;
						element.style.opacity=1;
						var si = setInterval(function(){
							element.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
							clearInterval(si);
						}, 1);
					} else {
						var ts = status.t / timeValues.fps;
						for(var k=gpConstants.fadeOutTime.length-1; k>=0; k--) {
							if(ts>=gpConstants.fadeOutTime[k]) {
								element.style.opacity = 1-gpConstants.fadeOutStrength[k];
								break;
							}
						}
					}
				}
			}
		};

		// ignite the gamepad update loop.
		rAF(gamepadDOMs.update);

		if(haveEvents) {
			window.addEventListener("gamepadconnected", function(e) {
				gamepadHandler.connect(e.gamepad);
			});
			window.addEventListener("gamepaddisconnected", function(e) {
				gamepadHandler.disconnect(e.gamepad);
			});
		} else if(haveWebkitEvents) {
			window.addEventListener("webkitgamepadconnected", function(e) {
				gamepadHandler.connect(e.gamepad);
			});
			window.addEventListener("webkitgamepaddisconnected", function(e) {
				gamepadHandler.disconnect(e.gamepad);
			});
		} else {
			var scanningWithNoEvents = setInterval(gamepadHandler.scan, 500);
		}
	</script>
	
	<body>
	</body>
	
</html>
