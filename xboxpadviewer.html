<!DOCTYPE html>
<html lang="en">

	<head>
		<meta content="text/html;charset=utf-8" http-equiv="content-type">
		<meta content="utf-8" http-equiv="encoding">
		<meta name="viewport"
					content="width=device-width, initial-scale=1.0" />
		<title></title>
		<!--<link rel="shortcut icon" href="/favicon.ico">
		<link rel="apple-touch-icon"
					href="./appiconios.png" />
		<link rel="apple-touch-icon-precomposed"
					href="./appiconandroid.png" />
		<link rel="stylesheet" href="./your.css">-->
		<link href="mapping.css" rel="stylesheet">
		<style>
			
		</style>
	</head>
	
	<!--<script src="./your.js"></script>-->
	<script>
		window.onload = function() {
			document.body.style.fontSize = "16px";
			timeValues.fpsCheck();
		};

		var gpConstants = {
			thumbSize: 60
			,pressedButtonColor: "orange"
			,axisSensitivity: 0
			,useFadeOut: true
			,fadeOutDuration: 4
			,fadeOutTime: [4, 12]
			,fadeOutStrength: [.5, .9]
		};
		var timeValues = {
			fps: 0
			,fpsChecked: false
			,fpsIncrease: function() {
				timeValues.fps++;
			}
			,fpsCheck: function() {
				var o = setTimeout(function() {
					timeValues.fpsChecked = true;
					clearTimeout(o);
				}, 1000);
			}
		};

		function cl(...t) {
			console.log(...t);
		};

		// for the 'in' keyword: I used the code below as a reference.
		// https://github.com/luser/gamepadtest/blob/master/gamepadtest.js
		var haveEvents = 'GamepadEvent' in window;
		var haveWebkitEvents = 'WebKitGamepadEvent' in window;
		var rAF = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.requestAnimationFrame;

		var gamepads = {};
		var gamepadTimestamps = {};
		function gamepadTimestamp() {
			var buttons = [];
			var axes = {};

			this.buttonAdd = function() { buttons.push({t:0,v:0}); }
			this.axisAdd = function(n) { axes[n] = {t:0,v:0}; }
			this.getButtonTimestamp = function(n) {
				return buttons[n].t;
			}
			this.getAxisTimestamp = function(n) {
				return axes[n].t;
			}

			this.age = function() {
				var max = timeValues.fps * gpConstants.fadeOutTime[gpConstants.fadeOutTime.length-1];
				for(var i=0; i<buttons.length; i++) {
					if(buttons[i].t<max) {
						buttons[i].t++;
					}
				}
				for(a in axes) {
					if(axes[a].t<max) {
						axes[a].t++;
					}
				}
			};

			this.buttonUpdate = function(n,v) {
				if(buttons[n].v !== v) {
					buttons[n].t = 0;
					buttons[n].v = v;
					return true;
				} else {
					return false;
				}
			};
			this.axisUpdate = function(n,v) {
				if(axes[n].v !== v) {
					axes[n].t = 0;
					axes[n].v = v;
					return true;
				} else {
					return false;
				}
			};

			this.showAll = function() {
				var txt = "";
				for(var i=0;i<buttons.length;i++) { txt+= `${buttons[i].t}${buttons[i].v} `; }
				cl(txt); txt="";
				for(a in axes) { txt+= `${a}:${axes[a].t}${axes[a].v} `; }
				cl(txt);
			}
		};

		var gamepadHandler = {
			connect: function(e) {
				gamepads[e.index] = e;
				cl("connected: %d", e.index);
				gamepadDOMs.add(e);
			},
			disconnect: function(index) {
				cl("disconnecting: %d", index);
				gamepadDOMs.remove(index);
				delete gamepads[index];
			},
			scan: function() {
				var gamepadsFromNavigator = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
				for(var i=0; i<gamepadsFromNavigator.length; i++) {
					if(gamepadsFromNavigator[i]) {
						if(gamepadsFromNavigator[i].index in gamepads) {
							gamepads[gamepadsFromNavigator[i].index] = gamepadsFromNavigator[i];
						} else {
							gamepadHandler.connect(gamepadsFromNavigator[i]);
						}
					} else if((gamepadsFromNavigator[i] === null || gamepadsFromNavigator[i] === undefined)
					&& document.getElementById(`gp${i}`)) {
						gamepadHandler.disconnect(i);
					}
				}
			}
		};

		var gamepadMapping = {
			"Microsoft Controller (Vendor: 045e Product: 02d1)": {
				buttons: [
					{name:"A", type:"button"}
					,{name:"B", type:"button"}
					,{name:"X", type:"button"}
					,{name:"Y", type:"button"}
					,{name:"LB", type:"button"}
					,{name:"RB", type:"button"}
					,{name:"Se", type:"button"}
					,{name:"St", type:"button"}
					,{name:"â“§", type:"button"}
					,{name:"L", type:"button thumb"}
					,{name:"R", type:"button thumb"}
				]
				,axes: [
					{name:"L", type:"thumb"}
					,{name:"L", type:"thumb"}
					,{name:"LT", type:"button shoulder"}
					,{name:"R", type:"thumb"}
					,{name:"R", type:"thumb"}
					,{name:"RT", type:"button shoulder"}
					,{name:"D", type:"button polar"}
					,{name:"D", type:"button polar"}
				]
			}
			,"Xbox 360 Controller (XInput STANDARD GAMEPAD)": {
				buttons: [
					{name:"A", type:"button"}
					,{name:"B", type:"button"}
					,{name:"X", type:"button"}
					,{name:"Y", type:"button"}
					,{name:"LB", type:"button"}
					,{name:"RB", type:"button"}
					,{name:"LT", type:"button"}
					,{name:"RT", type:"button"}
					,{name:"Se", type:"button"}
					,{name:"St", type:"button"}
					,{name:"L", type:"button thumb"}
					,{name:"R", type:"button thumb"}
					,{name:"U", type:"button"}
					,{name:"D", type:"button"}
					,{name:"L", type:"button"}
					,{name:"R", type:"button"}
				]
				,axes: [
					{name:"L", type:"thumb"}
					,{name:"L", type:"thumb"}
					,{name:"R", type:"thumb"}
					,{name:"R", type:"thumb"}
				]
			}
		};

		var gamepadDOMs = {
			add: function(gp) {
				var isLinuxXpad = gp.id==="Microsoft Controller (Vendor: 045e Product: 02d1)";
				// create a couple of arrays for tracking button's timestamp
				gamepadTimestamps[gp.index] = new gamepadTimestamp();
				var gt = gamepadTimestamps[gp.index];
				// create dom for a gamepad
				var d = document.createElement("div");
				d.setAttribute("id",`gp${gp.index}`);
				d.setAttribute("class",gp.id);
				// create dom for buttons
				var b = document.createElement("div");
				b.setAttribute("class","buttons");
				for(var i=0; i<gp.buttons.length; i++) {
					if(gamepadMapping[gp.id]) {
						var cur = gamepadMapping[gp.id].buttons[i];
						var e = document.createElement("span");
						if(cur.type === "button thumb") {
						} else {
							e.setAttribute("class",cur.type);
							e.innerHTML = `${cur.name}`;
						}
					} else {
						var e = document.createElement("span");
						e.setAttribute("class","button");
						e.innerHTML = i;
					}
					e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
					b.appendChild(e);
					gamepadTimestamps[gp.index].buttonAdd();
				}
				d.appendChild(b);
				// create dom for axes
				var a = document.createElement("div");
				a.setAttribute("class","axes");
				var c; // c resides in e and represent the position of thumb stick.
				for(i=0; i<gp.axes.length; i++) {
					if(gamepadMapping[gp.id]) {
						var cur = gamepadMapping[gp.id].axes[i];
						if(cur.type === "thumb") {
							if(a.getElementsByClassName(`axis ${cur.name}`).length) {
								c.style.top = `${gpConstants.thumbSize/2}%`;
							} else {
								e = document.createElement("span");
								e.setAttribute("class",`axis ${cur.name}`);
								c = document.createElement("span");
								c.style.width = `${gpConstants.thumbSize}%`;
								c.style.height = `${gpConstants.thumbSize}%`;
								c.style.left = `${gpConstants.thumbSize/2}%`;
								e.appendChild(c);
								e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
								a.appendChild(e);
								gamepadTimestamps[gp.index].axisAdd(cur.name);
							}
						} else if(cur.type.match("button")) {
							e = document.createElement("span");
							e.setAttribute("class",cur.type);
							if(isLinuxXpad) {
								if(cur.type.match("shoulder")) {
									e.innerHTML = cur.name;
								} else if(cur.type.match("polar")) {
									// Hardcode......
									e.innerHTML = i===6?"R":"D";
									var e2 = e.cloneNode(false);
									e2.innerHTML = i===6?"L":"U";
									e2.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
									b.appendChild(e2);
									gamepadTimestamps[gp.index].buttonAdd();
								}
							}
							e.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
							b.appendChild(e);
							gamepadTimestamps[gp.index].buttonAdd();
						}
					} else {
						e = document.createElement("span");
						e.setAttribute("class","axis");
						e.innerHTML = `${i} `;
						a.appendChild(e);
					}
				}
				d.appendChild(a);
				// attach gamepad dom to the document
				document.body.appendChild(d);

				rAF(gamepadDOMs.update);
			},
			remove: function(index) {
				var d = document.getElementById(`gp${index}`);
				document.body.removeChild(d);
				delete gamepadTimestamps[index];
			},
			update: function() {
				gamepadHandler.scan();
				if(!timeValues.fpsChecked) {
					timeValues.fpsIncrease();
				}
				for(j in gamepads) {
					var gp = gamepads[j];
					var gts = gamepadTimestamps[gp.index];
					var isLinuxXpad = gp.id==="Microsoft Controller (Vendor: 045e Product: 02d1)";
					gts.age();
					var d = document.getElementById(`gp${gp.index}`);

					var b = d.getElementsByClassName("buttons")[0];
					for(var i=0; i<gp.buttons.length; i++) {
						var cur = gamepadMapping[gp.id].buttons[i];
						var e;
						var es = gp.buttons[i]; // each status of buttons
						var val = 100*es.value;
						if(cur.type === "button thumb") {
							e = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0];
							if(val===100) {
								e.style.background = "url(dot.png)";
							} else {
								e.style.background = "white";
							}
							// gamepadDOMs.opacityControl(
							// 	gts.buttonUpdate(i, val), 
							// 	gts.getButtonTimestamp(i), 
							// 	e
							// );
						} else {
							e = b.children[i]; // each dom for buttons
							e.style.backgroundSize = `100% ${val}%`;
							if(val) {
								e.style.color = gpConstants.pressedButtonColor;
							} else {
								e.style.color = "white";
							}
							gamepadDOMs.opacityControl(
								gts.buttonUpdate(i, val), 
								gts.getButtonTimestamp(i),
								e
							);
						}
					}
					
					var a;
					for(i=0; i<gp.axes.length; i++) {
						if(gamepadMapping[gp.id]) {
							var cur = gamepadMapping[gp.id].axes[i];
							var val = gp.axes[i];
							if(cur.type === "thumb") {
								a = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0];
								var thumbMargin = (100-gpConstants.thumbSize)/2;

								var linuxXpadCalibration = isLinuxXpad && (i===3||i===4);
								if(linuxXpadCalibration) {
									i===3?i=4:i=3;
								} 
								if(i%2) {
									if(linuxXpadCalibration) {
										i===3?i=4:i=3;
									}
									a.style.top = `${thumbMargin+thumbMargin*val}%`;
								} else {
									if(linuxXpadCalibration) {
										i===3?i=4:i=3;
									}
									a.style.left = `${thumbMargin+thumbMargin*val}%`;
								}
								var valSerialized = 
								Math.pow(10,2*gpConstants.axisSensitivity)
								*parseFloat(a.style.left).toFixed(gpConstants.axisSensitivity)
								+Math.pow(10,gpConstants.axisSensitivity)
								*parseFloat(a.style.top).toFixed(gpConstants.axisSensitivity);
								gamepadDOMs.opacityControl(
									gts.axisUpdate(cur.name,valSerialized), 
									gts.getAxisTimestamp(cur.name),
									a.parentElement);
							} else if(cur.type.match("button")) {
								if(isLinuxXpad) {
									var buttonNumber;
									if(cur.type.match("shoulder")) {
										buttonNumber = i===2?11:12;
										e = b.children[buttonNumber];
										val = 50+Math.floor(50*val);
										if(val) {
											e.style.color = gpConstants.pressedButtonColor;
										} else {
											e.style.color = "white";
										}
										e.style.backgroundSize = `100% ${val}%`;
										gamepadDOMs.opacityControl(
											gts.buttonUpdate(buttonNumber, val), 
											gts.getButtonTimestamp(buttonNumber),
											e
										);
									} else if(cur.type.match("polar")) {
										var dpadX = i===6;
										var currentMinusPolarButton = dpadX?13:15;
										var currentPlusPolarButton = dpadX?14:16;
										buttonNumber
										= val>0?
												currentPlusPolarButton
												:val<0?
													currentMinusPolarButton
													:0;
										val = Math.abs(100*val);
										if(buttonNumber) {
											e = b.children[buttonNumber];
											e.style.backgroundSize = `100% ${val}%`;
											e.style.color = gpConstants.pressedButtonColor;
										} else {
											e = b.children[currentMinusPolarButton];
											e.style.backgroundSize
											= e.nextSibling.style.backgroundSize
											= "100% 0%";
											e.style.color
											= e.nextSibling.style.color
											= "white";
										}
										if(buttonNumber) {
											gamepadDOMs.opacityControl(
												gts.buttonUpdate(buttonNumber, val), 
												gts.getButtonTimestamp(buttonNumber),
												e
											);
										} else {
											gamepadDOMs.opacityControl(
												gts.buttonUpdate(currentMinusPolarButton, 0),
												gts.getButtonTimestamp(currentMinusPolarButton),
												b.children[currentMinusPolarButton]
											);
											gamepadDOMs.opacityControl(
												gts.buttonUpdate(currentPlusPolarButton, 0),
												gts.getButtonTimestamp(currentPlusPolarButton),
												b.children[currentPlusPolarButton]
											);
										}
									}
								}
							}
						} else {
							var a = d.getElementsByClassName("axis");
							e = a[i];
							e.innerHTML = `${i}${gp.axes[i].toFixed(4)} `;
						}
					}

				}
				rAF(gamepadDOMs.update);
			}
			,opacityControl: function(isChanged, timestamp, element) {
				if(element) {
					if(isChanged) {
						element.style.transition=`opacity 0s`;
						element.style.opacity=1;
						var si = setInterval(function(){
							element.style.transition=`opacity ${gpConstants.fadeOutDuration}s`;
							clearInterval(si);
						}, 1);
					} else {
						var ts = timestamp / timeValues.fps;
						for(var k=gpConstants.fadeOutTime.length-1; k>=0; k--) {
							if(ts>=gpConstants.fadeOutTime[k]) {
								element.style.opacity = 1-gpConstants.fadeOutStrength[k];
								break;
							}
						}
					}
				}
			}
		};

		rAF(gamepadDOMs.update);
		if(haveEvents) {
				window.addEventListener("gamepadconnected", function(e) {
					gamepadHandler.connect(e.gamepad);
				});
			//window.addEventListener("gamepadconnected", gamepadHandler.scan);
			window.addEventListener("gamepaddisconnected", function(e) {
				gamepadHandler.disconnect(e.gamepad);
			});
		} else if(haveWebkitEvents) {
				window.addEventListener("webkitgamepadconnected", function(e) {
					gamepadHandler.connect(e.gamepad);
				});
			//window.addEventListener("webkitgamepadconnected", gamepadHandler.scan);
			window.addEventListener("webkitgamepaddisconnected", function(e) {
				gamepadHandler.disconnect(e.gamepad);
			});
		} else {
			var scanningWithNoEvents = setInterval(gamepadHandler.scan, 500);
		}
	</script>
	
	<body>
	</body>
	
</html>
